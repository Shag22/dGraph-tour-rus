+++
date =  "2017-04-26T22:28:55+10:00"
next = "/basic/6"
prev = "/basic/4"
title = "Запросы описывающие графы"
weight = 5
+++

Результаты запроса Dgraph являются графами. Фактически структура результата соответствует структуре запроса.

Скобки edge_name { ... } в запросе означают вложенные блоки, в которых рёбра внутри блока сопоставляются с найденными узлами, следуя по краю, начинающему блок. Продолжаем вложенный запрос, следуя по рёбрам от узла к узлу.

Хотя это не строго обязательно, но это хороший тон, чтобы отступить от запроса.

Сравните результат JSON со структурой запроса и обратите внимание, например, что ребро friend совпадает с нескольким узлам, каждый из которых представлен в JSON.

Попробуйте так: как насчет домашних животных друзей Майкла или друзей друзей Майкла.

{{% expandable %}} Поспрашивайте о домашних животных друзей Майкла:

{
  michael_friends_pets(func: eq(name, "Michael")) {
    name
    age
    friend {
      name@.
      owns_pet {
        name
      }
    }
  }
}

Поспрашивайте друзей Майкла:

{
  michael_friends_friends(func: allofterms(name, "Michael")) {
    name
    age
    friend {
      name@.
      friend {
        name@.
      }
    }
  }
}

{{% /expandable %}}

Идея заключается в том, чтобы сформулировать запрос как обходной путь по графу,следуя по краям к нужным данным. Вывод uid в JSON позволяет интерпретировать запрос как граф, а не дерево. Например, циклы «‎друзья друзей Майкла».
